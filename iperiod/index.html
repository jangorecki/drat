<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: Round datetime</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body>

<table width="100%" summary="page for periodize"><tr><td>periodize</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>Round datetime</h2>

<h3>Description</h3>

<p>Periodize datetime object by rounding <em>ceiling</em> or <em>floor</em> to neaerst period defined by <code>unit</code> and <code>amount</code>.</p>


<h3>Usage</h3>

<pre>
periodize(idate, itime = 0L, unit, amount = 1L, origin = "1970-01-01", type = "ceiling")

as.IPeriod(x, ...)
## Default S3 method:
as.IPeriod(x, unit, amount = 1L, origin = "1970-01-01", type = "ceiling", ...)
## S3 method for class 'POSIXct'
as.IPeriod(x, unit, amount = 1L, origin = "1970-01-01", type = "ceiling", ...)
## S3 method for class 'data.table'
as.IPeriod(x, unit, amount = 1L, origin = "1970-01-01", type = "ceiling", ...)
## S3 method for class 'IDate'
as.IPeriod(x, unit, amount = 1L, origin = "1970-01-01", type = "ceiling", itime = 0L, ...)

as.factor.IPeriod(x) # do not use without setting `origin`, read notes
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>idate</code></td>
<td>
<p><em>POSIXct, IDate, IDateTime-like data.table</em>, if <em>IDate</em> then also <code>itime</code> is expected to be provided.</p>
</td></tr>
<tr valign="top"><td><code>itime</code></td>
<td>
<p>ITime class object. If <code>x</code> is not a <em>IDate</em> then this argument can be removed, allowing simple <code>periodize(posixct, "hours")</code> calls.</p>
</td></tr>
<tr valign="top"><td><code>x</code></td>
<td>
<p>object to be converted to <em>IPeriod</em>, accepted are <em>POSIXct, IDate, IDateTime-like data.table</em>.</p>
</td></tr>
<tr valign="top"><td><code>unit</code></td>
<td>
<p>character scalar, one of <em>secs, mins, hours, days</em>.</p>
</td></tr>
<tr valign="top"><td><code>amount</code></td>
<td>
<p>integer amount of the unit that forms single period.</p>
</td></tr>
<tr valign="top"><td><code>origin</code></td>
<td>
<p>character date format of origin to be used as internal start of integer values. Default <em>1970-01-01</em>.</p>
</td></tr>
<tr valign="top"><td><code>type</code></td>
<td>
<p>character scalar, one of <em>ceiling, floor</em>, also <em>up, down</em> supported. Default <em>ceiling</em>.</p>
</td></tr>
<tr valign="top"><td><code>...</code></td>
<td>
<p>argument to be matched in methods, e.g. <code>itime</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>periodize</code> is just a wrapper to <code>as.IPeriod</code> which has to make it handy to use in data.table <code>DT[, .(hourly_mean = mean(x)), .(iperiod = periodize(idate,itime,"hours")]</code>. It handle reordering unnamed input arguments when <code>x</code> is <em>POSIXct, data.table</em> by removing <code>itime</code> from the expected argument sequence, allowing simple <code>periodize(posixct, "hours", 15L)</code> calls. It also has some defaults.
</p>


<h3>Value</h3>

<p>Integer based <em>IPeriod</em> class. Four attributes attached <em>unit, amount, origin, type</em>.</p>


<h3>Note</h3>

<p>Use tight <code>origin</code> argument for potential speed-up when &lt; 100k values (see IDateTime), or in case of using <code>as.factor.IPeriod</code> because factor levels will start from <code>origin</code> value, see examples.
Timezone should be handled after extracting date from IPeriod, e.g. <code>as.POSIXct(iperiod, tz="")</code>. IPeriod data with different attributes should not be compared to each other. 
</p>


<h3>Author(s)</h3>

<p>Jan Gorecki</p>


<h3>See Also</h3>

<p>IDateTime, IDate, ITime</p>


<h3>Examples</h3>

<pre>
# basic usage IPeriod
x = as.POSIXct("2015-10-13 09:48:15", tz="UTC")
print(x)
# rounding ceiling or floor to flexible time periods
as.IPeriod(x, "hours", 12)
as.IPeriod(x, "mins", 10)
as.IPeriod(x, "secs", 15)
as.IPeriod(x, "secs", 15, type = "floor")

# input args dynamic matching
idt = IDateTime(x)
# POSIXct
periodize(x, "hours", 2)
# IDateTime
periodize(idt, "hours", 2)
# IDate, ITime
periodize(idt$idate, idt$itime, "hours", 2)

# use to aggregate dataset
set.seed(1)
DT = data.table(ts = as.POSIXct(1444857558L+3600L*c(1:100)/10, tz="UTC", origin="1970-01-01"),
                x = rnorm(100))
# group by periodize of idate and itime fields
DT[, c("idate","itime") := IDateTime(ts)]
DT[, .(hourly_mean = mean(x),
       hourly_pos = sum(x &gt; 0),
       hourly_neg = sum(x &lt; 0),
       range = diff(range(x))),
   .(iperiod = periodize(idate, itime, "hours"))]
# group by periodize directly on POSIXct
DT[, .(hourly_mean = mean(x),
       hourly_pos = sum(x &gt; 0),
       hourly_neg = sum(x &lt; 0),
       range = diff(range(x))),
   .(iperiod = periodize(ts, "hours"))]

# extract from IPeriod
p = as.IPeriod(x, "hours", 12)
as.character(p)
as.POSIXct(p, tz="UTC")
as.IDate(p)
as.ITime(p)
IDateTime(p)
# don't try `as.factor` without setting `origin`!

# origin and as.factor
(p = periodize(x, "hours", 6, origin = "2015-10-13"))
as.factor.IPeriod(p)
(p = periodize(x, "hours", 6, origin = "2015-10-01"))
as.factor.IPeriod(p)
# input of: "hours", 6, origin = "1970-01-01" (default!)
# produces factor of 60k+ levels!

# input of: unit="secs", amount=1L
# produces 1s periods, which maps to POSIXct based numeric
now = Sys.time()
attr(now, "tzone") &lt;- "UTC"
periodize(now, "secs", type = "floor") == as.integer(now)
periodize(now, "secs") == as.integer(now) + 1L
</pre>


</body></html>
